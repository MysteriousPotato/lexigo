// Code generated by lexigo - DO NOT EDIT
package test

import (
	"context"
	"fmt"

	"github.com/MysteriousPotato/lexigo/cmd/lexigogen/test/other"
	lexigo "github.com/MysteriousPotato/lexigo/pkg"
	"golang.org/x/text/language"
)

var (
	ar    = language.MustParse("ar")
	en_US = language.MustParse("en-US")
	fr    = language.MustParse("fr")
)

var Matcher = lexigo.NewMatcher([]language.Tag{en_US, ar, fr})

type locale interface {
	ar() string
	en_US() string
	fr() string
}

type placeholders interface {
	ar() []any
	en_US() []any
	fr() []any
}

type Locale struct {
	locale       locale
	placeholders placeholders
}

func (l Locale) parse(lang language.Tag) string {
	switch Matcher.Match(lang) {
	case ar:
		if l.placeholders == nil {
			return l.locale.ar()
		}
		return fmt.Sprintf(l.locale.ar(), l.placeholders.ar()...)
	case fr:
		if l.placeholders == nil {
			return l.locale.fr()
		}
		return fmt.Sprintf(l.locale.fr(), l.placeholders.fr()...)
	default:
		if l.placeholders == nil {
			return l.locale.en_US()
		}
		return fmt.Sprintf(l.locale.en_US(), l.placeholders.en_US()...)
	}
}

func (l Locale) FromCtx(ctx context.Context) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang)
}

func (l Locale) FromString(lang string) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag)
}

func (l Locale) FromTag(lang language.Tag) string {
	return l.parse(lang)
}

var Locales = localesNested{MyLocaleAny: myLocaleAnyLocale{}, MyLocaleFloat: myLocaleFloatLocale{}, MyLocaleInt: myLocaleIntLocale{}, MyLocale: myLocaleLocale{}, MyLocaleOther: myLocaleOtherLocale{}, MyLocaleStr: myLocaleStrLocale{}, Outer1: outer1LocaleNested{}, Outer2: outer2LocaleNested{}, Outer3: outer3LocaleNested{}, Outer4: outer4LocaleNested{}, Outer5: outer5LocaleNested{}}

type localesNested struct {
	MyLocaleAny   myLocaleAnyLocale
	MyLocaleFloat myLocaleFloatLocale
	MyLocaleInt   myLocaleIntLocale
	MyLocale      myLocaleLocale
	MyLocaleOther myLocaleOtherLocale
	MyLocaleStr   myLocaleStrLocale
	Outer1        outer1LocaleNested
	Outer2        outer2LocaleNested
	Outer3        outer3LocaleNested
	Outer4        outer4LocaleNested
	Outer5        outer5LocaleNested
}

type outer1LocaleNested struct {
	Inner outer1InnerLocale
}

type outer2LocaleNested struct {
	Inner outer2InnerLocale
}

type outer3LocaleNested struct {
	Outer1 outer3Outer1LocaleNested
}

type outer3Outer1LocaleNested struct {
	Inner outer3Outer1InnerLocale
}

type outer4LocaleNested struct {
	Outer1 outer4Outer1LocaleNested
}

type outer4Outer1LocaleNested struct {
	Inner outer4Outer1InnerLocale
}

type outer5LocaleNested struct {
	Outer6 outer6LocaleNested
}

type outer6LocaleNested struct {
	Outer1 outer6Outer1LocaleNested
}

type outer6Outer1LocaleNested struct {
	Inner outer6Outer1InnerLocale
}

type myLocaleAnyLocale struct{}

func (l myLocaleAnyLocale) ar() string {
	return "myLocale %+v ar"
}

func (l myLocaleAnyLocale) en_US() string {
	return "myLocale %+v"
}

func (l myLocaleAnyLocale) fr() string {
	return "myLocale %+v fr"
}

func (l myLocaleAnyLocale) parse(lang language.Tag, placeholders MyLocaleAnyPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l myLocaleAnyLocale) FromCtx(ctx context.Context, placeholders MyLocaleAnyPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l myLocaleAnyLocale) FromString(lang string, placeholders MyLocaleAnyPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l myLocaleAnyLocale) FromTag(lang language.Tag, placeholders MyLocaleAnyPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l myLocaleAnyLocale) Locale(placeholders MyLocaleAnyPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type MyLocaleAnyPlaceholders struct {
	Placeholder any
}

func (p MyLocaleAnyPlaceholders) ar() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleAnyPlaceholders) en_US() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleAnyPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

type myLocaleFloatLocale struct{}

func (l myLocaleFloatLocale) ar() string {
	return "myLocale %.2f ar"
}

func (l myLocaleFloatLocale) en_US() string {
	return "myLocale %.2f"
}

func (l myLocaleFloatLocale) fr() string {
	return "myLocale %.2f fr"
}

func (l myLocaleFloatLocale) parse(lang language.Tag, placeholders MyLocaleFloatPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l myLocaleFloatLocale) FromCtx(ctx context.Context, placeholders MyLocaleFloatPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l myLocaleFloatLocale) FromString(lang string, placeholders MyLocaleFloatPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l myLocaleFloatLocale) FromTag(lang language.Tag, placeholders MyLocaleFloatPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l myLocaleFloatLocale) Locale(placeholders MyLocaleFloatPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type MyLocaleFloatPlaceholders struct {
	Placeholder float32
}

func (p MyLocaleFloatPlaceholders) ar() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleFloatPlaceholders) en_US() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleFloatPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

type myLocaleIntLocale struct{}

func (l myLocaleIntLocale) ar() string {
	return "myLocale %d"
}

func (l myLocaleIntLocale) en_US() string {
	return "myLocale %d"
}

func (l myLocaleIntLocale) fr() string {
	return "myLocale %d"
}

func (l myLocaleIntLocale) parse(lang language.Tag, placeholders MyLocaleIntPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l myLocaleIntLocale) FromCtx(ctx context.Context, placeholders MyLocaleIntPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l myLocaleIntLocale) FromString(lang string, placeholders MyLocaleIntPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l myLocaleIntLocale) FromTag(lang language.Tag, placeholders MyLocaleIntPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l myLocaleIntLocale) Locale(placeholders MyLocaleIntPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type MyLocaleIntPlaceholders struct {
	Placeholder int
}

func (p MyLocaleIntPlaceholders) ar() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleIntPlaceholders) en_US() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleIntPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

type myLocaleLocale struct{}

func (l myLocaleLocale) ar() string {
	return "myLocale % ar"
}

func (l myLocaleLocale) en_US() string {
	return "myLocale %"
}

func (l myLocaleLocale) fr() string {
	return "myLocale % fr"
}

func (l myLocaleLocale) parse(lang language.Tag) string {
	switch Matcher.Match(lang) {
	case ar:
		return l.ar()
	case fr:
		return l.fr()
	default:
		return l.en_US()
	}
}

func (l myLocaleLocale) FromCtx(ctx context.Context) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang)
}

func (l myLocaleLocale) FromString(lang string) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag)
}

func (l myLocaleLocale) FromTag(lang language.Tag) string {
	return l.parse(lang)
}

func (l myLocaleLocale) Locale() Locale {
	return Locale{locale: l}
}

type myLocaleOtherLocale struct{}

func (l myLocaleOtherLocale) ar() string {
	return "myLocale %v ar"
}

func (l myLocaleOtherLocale) en_US() string {
	return "myLocale %v"
}

func (l myLocaleOtherLocale) fr() string {
	return "myLocale %v fr"
}

func (l myLocaleOtherLocale) parse(lang language.Tag, placeholders MyLocaleOtherPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l myLocaleOtherLocale) FromCtx(ctx context.Context, placeholders MyLocaleOtherPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l myLocaleOtherLocale) FromString(lang string, placeholders MyLocaleOtherPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l myLocaleOtherLocale) FromTag(lang language.Tag, placeholders MyLocaleOtherPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l myLocaleOtherLocale) Locale(placeholders MyLocaleOtherPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type MyLocaleOtherPlaceholders struct {
	Placeholder other.Other
}

func (p MyLocaleOtherPlaceholders) ar() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleOtherPlaceholders) en_US() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleOtherPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

type myLocaleStrLocale struct{}

func (l myLocaleStrLocale) ar() string {
	return "myLocale %% %q ar"
}

func (l myLocaleStrLocale) en_US() string {
	return "myLocale %% %q"
}

func (l myLocaleStrLocale) fr() string {
	return "myLocale %% %q fr"
}

func (l myLocaleStrLocale) parse(lang language.Tag, placeholders MyLocaleStrPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l myLocaleStrLocale) FromCtx(ctx context.Context, placeholders MyLocaleStrPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l myLocaleStrLocale) FromString(lang string, placeholders MyLocaleStrPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l myLocaleStrLocale) FromTag(lang language.Tag, placeholders MyLocaleStrPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l myLocaleStrLocale) Locale(placeholders MyLocaleStrPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type MyLocaleStrPlaceholders struct {
	Placeholder string
}

func (p MyLocaleStrPlaceholders) ar() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleStrPlaceholders) en_US() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleStrPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

type outer1InnerLocale struct{}

func (l outer1InnerLocale) ar() string {
	return "nested 1 %s %s ar"
}

func (l outer1InnerLocale) en_US() string {
	return "nested 1 %s %s"
}

func (l outer1InnerLocale) fr() string {
	return "nested 1 %s %s fr"
}

func (l outer1InnerLocale) parse(lang language.Tag, placeholders Outer1InnerPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l outer1InnerLocale) FromCtx(ctx context.Context, placeholders Outer1InnerPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l outer1InnerLocale) FromString(lang string, placeholders Outer1InnerPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l outer1InnerLocale) FromTag(lang language.Tag, placeholders Outer1InnerPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l outer1InnerLocale) Locale(placeholders Outer1InnerPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type Outer1InnerPlaceholders struct {
	Placeholder1 string
	Placeholder2 string
}

func (p Outer1InnerPlaceholders) ar() []any {
	return []any{p.Placeholder2, p.Placeholder1}
}

func (p Outer1InnerPlaceholders) en_US() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer1InnerPlaceholders) fr() []any {
	return []any{p.Placeholder2, p.Placeholder1}
}

type outer2InnerLocale struct{}

func (l outer2InnerLocale) ar() string {
	return "nested 2 %s %s ar"
}

func (l outer2InnerLocale) en_US() string {
	return "nested 2 %s %s"
}

func (l outer2InnerLocale) fr() string {
	return "nested 2 %s %s fr"
}

func (l outer2InnerLocale) parse(lang language.Tag, placeholders Outer2InnerPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l outer2InnerLocale) FromCtx(ctx context.Context, placeholders Outer2InnerPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l outer2InnerLocale) FromString(lang string, placeholders Outer2InnerPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l outer2InnerLocale) FromTag(lang language.Tag, placeholders Outer2InnerPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l outer2InnerLocale) Locale(placeholders Outer2InnerPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type Outer2InnerPlaceholders struct {
	Placeholder1 string
	Placeholder2 string
}

func (p Outer2InnerPlaceholders) ar() []any {
	return []any{p.Placeholder2, p.Placeholder1}
}

func (p Outer2InnerPlaceholders) en_US() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer2InnerPlaceholders) fr() []any {
	return []any{p.Placeholder2, p.Placeholder1}
}

type outer3Outer1InnerLocale struct{}

func (l outer3Outer1InnerLocale) ar() string {
	return "nested 3 %s %s ar"
}

func (l outer3Outer1InnerLocale) en_US() string {
	return "nested 3 %s %s"
}

func (l outer3Outer1InnerLocale) fr() string {
	return "nested 3 %s %s fr"
}

func (l outer3Outer1InnerLocale) parse(lang language.Tag, placeholders Outer3Outer1InnerPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l outer3Outer1InnerLocale) FromCtx(ctx context.Context, placeholders Outer3Outer1InnerPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l outer3Outer1InnerLocale) FromString(lang string, placeholders Outer3Outer1InnerPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l outer3Outer1InnerLocale) FromTag(lang language.Tag, placeholders Outer3Outer1InnerPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l outer3Outer1InnerLocale) Locale(placeholders Outer3Outer1InnerPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type Outer3Outer1InnerPlaceholders struct {
	Placeholder1 string
	Placeholder2 string
}

func (p Outer3Outer1InnerPlaceholders) ar() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer3Outer1InnerPlaceholders) en_US() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer3Outer1InnerPlaceholders) fr() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

type outer4Outer1InnerLocale struct{}

func (l outer4Outer1InnerLocale) ar() string {
	return "nested 4 %s %s ar"
}

func (l outer4Outer1InnerLocale) en_US() string {
	return "nested 4 %s %s"
}

func (l outer4Outer1InnerLocale) fr() string {
	return "nested 4 %s %s fr"
}

func (l outer4Outer1InnerLocale) parse(lang language.Tag, placeholders Outer4Outer1InnerPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l outer4Outer1InnerLocale) FromCtx(ctx context.Context, placeholders Outer4Outer1InnerPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l outer4Outer1InnerLocale) FromString(lang string, placeholders Outer4Outer1InnerPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l outer4Outer1InnerLocale) FromTag(lang language.Tag, placeholders Outer4Outer1InnerPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l outer4Outer1InnerLocale) Locale(placeholders Outer4Outer1InnerPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type Outer4Outer1InnerPlaceholders struct {
	Placeholder1 string
	Placeholder2 string
}

func (p Outer4Outer1InnerPlaceholders) ar() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer4Outer1InnerPlaceholders) en_US() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer4Outer1InnerPlaceholders) fr() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

type outer6Outer1InnerLocale struct{}

func (l outer6Outer1InnerLocale) ar() string {
	return "nested 4 %s %s ar"
}

func (l outer6Outer1InnerLocale) en_US() string {
	return "nested 4 %s %s"
}

func (l outer6Outer1InnerLocale) fr() string {
	return "nested 4 %s %s fr"
}

func (l outer6Outer1InnerLocale) parse(lang language.Tag, placeholders Outer6Outer1InnerPlaceholders) string {
	switch Matcher.Match(lang) {
	case ar:
		return fmt.Sprintf(l.ar(), placeholders.ar()...)
	case fr:
		return fmt.Sprintf(l.fr(), placeholders.fr()...)
	default:
		return fmt.Sprintf(l.en_US(), placeholders.en_US()...)
	}
}

func (l outer6Outer1InnerLocale) FromCtx(ctx context.Context, placeholders Outer6Outer1InnerPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.parse(lang, placeholders)
}

func (l outer6Outer1InnerLocale) FromString(lang string, placeholders Outer6Outer1InnerPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.parse(tag, placeholders)
}

func (l outer6Outer1InnerLocale) FromTag(lang language.Tag, placeholders Outer6Outer1InnerPlaceholders) string {
	return l.parse(lang, placeholders)
}

func (l outer6Outer1InnerLocale) Locale(placeholders Outer6Outer1InnerPlaceholders) Locale {
	return Locale{locale: l, placeholders: placeholders}
}

type Outer6Outer1InnerPlaceholders struct {
	Placeholder1 string
	Placeholder2 string
}

func (p Outer6Outer1InnerPlaceholders) ar() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer6Outer1InnerPlaceholders) en_US() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p Outer6Outer1InnerPlaceholders) fr() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}
