// Code generated by lexigo - DO NOT EDIT
package test

import (
	"context"
	"fmt"
	"github.com/MysteriousPotato/lexigo/pkg"
	"golang.org/x/text/language"
)

var (
	en = language.MustParse("en")
	fr = language.MustParse("fr")
)

var Matcher = language.NewMatcher([]language.Tag{en, fr})

type locale struct {
	en string
	fr string
}

var myLocaleValue = myLocale{
	en: "myLocale",
	fr: "myLocale fr",
}

type myLocale locale

func (l myLocale) new(lang language.Tag, level int) string {
	if level == 1 {
		lang, _, _ = Matcher.Match(lang)
	}
	switch lang {
	case en:
		return fmt.Sprintf(l.en)
	case fr:
		return fmt.Sprintf(l.fr)
	}
	parent := lang
	if level > 0 {
		parent = lang.Parent()
	}
	return l.new(parent, level+1)
}

func (l myLocale) New(ctx context.Context) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.new(lang, 0)
}

func (l myLocale) NewFromString(lang string) string {
	tag, _ := language.Parse(lang)
	return l.new(tag, 0)
}

func (l myLocale) NewFromTag(lang language.Tag) string {
	return l.new(lang, 0)
}

var myLocaleAnyValue = myLocaleAny{
	en: "myLocale %v",
	fr: "myLocale %v fr",
}

type myLocaleAny locale

func (l myLocaleAny) new(lang language.Tag, level int, placeholders MyLocaleAnyPlaceholders) string {
	if level == 1 {
		lang, _, _ = Matcher.Match(lang)
	}
	switch lang {
	case en:
		return fmt.Sprintf(l.en, placeholders.en()...)
	case fr:
		return fmt.Sprintf(l.fr, placeholders.fr()...)
	}
	parent := lang
	if level > 0 {
		parent = lang.Parent()
	}
	return l.new(parent, level+1, placeholders)
}

func (l myLocaleAny) New(ctx context.Context, placeholders MyLocaleAnyPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.new(lang, 0, placeholders)
}

func (l myLocaleAny) NewFromString(lang string, placeholders MyLocaleAnyPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.new(tag, 0, placeholders)
}

func (l myLocaleAny) NewFromTag(lang language.Tag, placeholders MyLocaleAnyPlaceholders) string {
	return l.new(lang, 0, placeholders)
}

type MyLocaleAnyPlaceholders struct {
	Placeholder any
}

func (p MyLocaleAnyPlaceholders) en() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleAnyPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

var myLocaleFloatValue = myLocaleFloat{
	en: "myLocale %f",
	fr: "myLocale %f fr",
}

type myLocaleFloat locale

func (l myLocaleFloat) new(lang language.Tag, level int, placeholders MyLocaleFloatPlaceholders) string {
	if level == 1 {
		lang, _, _ = Matcher.Match(lang)
	}
	switch lang {
	case en:
		return fmt.Sprintf(l.en, placeholders.en()...)
	case fr:
		return fmt.Sprintf(l.fr, placeholders.fr()...)
	}
	parent := lang
	if level > 0 {
		parent = lang.Parent()
	}
	return l.new(parent, level+1, placeholders)
}

func (l myLocaleFloat) New(ctx context.Context, placeholders MyLocaleFloatPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.new(lang, 0, placeholders)
}

func (l myLocaleFloat) NewFromString(lang string, placeholders MyLocaleFloatPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.new(tag, 0, placeholders)
}

func (l myLocaleFloat) NewFromTag(lang language.Tag, placeholders MyLocaleFloatPlaceholders) string {
	return l.new(lang, 0, placeholders)
}

type MyLocaleFloatPlaceholders struct {
	Placeholder float64
}

func (p MyLocaleFloatPlaceholders) en() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleFloatPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

var myLocaleIntValue = myLocaleInt{
	en: "myLocale %d",
	fr: "myLocale %d fr",
}

type myLocaleInt locale

func (l myLocaleInt) new(lang language.Tag, level int, placeholders MyLocaleIntPlaceholders) string {
	if level == 1 {
		lang, _, _ = Matcher.Match(lang)
	}
	switch lang {
	case en:
		return fmt.Sprintf(l.en, placeholders.en()...)
	case fr:
		return fmt.Sprintf(l.fr, placeholders.fr()...)
	}
	parent := lang
	if level > 0 {
		parent = lang.Parent()
	}
	return l.new(parent, level+1, placeholders)
}

func (l myLocaleInt) New(ctx context.Context, placeholders MyLocaleIntPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.new(lang, 0, placeholders)
}

func (l myLocaleInt) NewFromString(lang string, placeholders MyLocaleIntPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.new(tag, 0, placeholders)
}

func (l myLocaleInt) NewFromTag(lang language.Tag, placeholders MyLocaleIntPlaceholders) string {
	return l.new(lang, 0, placeholders)
}

type MyLocaleIntPlaceholders struct {
	Placeholder int64
}

func (p MyLocaleIntPlaceholders) en() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleIntPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

var myLocaleStrValue = myLocaleStr{
	en: "myLocale %s",
	fr: "myLocale %s fr",
}

type myLocaleStr locale

func (l myLocaleStr) new(lang language.Tag, level int, placeholders MyLocaleStrPlaceholders) string {
	if level == 1 {
		lang, _, _ = Matcher.Match(lang)
	}
	switch lang {
	case en:
		return fmt.Sprintf(l.en, placeholders.en()...)
	case fr:
		return fmt.Sprintf(l.fr, placeholders.fr()...)
	}
	parent := lang
	if level > 0 {
		parent = lang.Parent()
	}
	return l.new(parent, level+1, placeholders)
}

func (l myLocaleStr) New(ctx context.Context, placeholders MyLocaleStrPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.new(lang, 0, placeholders)
}

func (l myLocaleStr) NewFromString(lang string, placeholders MyLocaleStrPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.new(tag, 0, placeholders)
}

func (l myLocaleStr) NewFromTag(lang language.Tag, placeholders MyLocaleStrPlaceholders) string {
	return l.new(lang, 0, placeholders)
}

type MyLocaleStrPlaceholders struct {
	Placeholder string
}

func (p MyLocaleStrPlaceholders) en() []any {
	return []any{p.Placeholder}
}

func (p MyLocaleStrPlaceholders) fr() []any {
	return []any{p.Placeholder}
}

var innerValue = inner{
	en: "nested %s %v",
	fr: "nested %v %s fr",
}

type inner locale

func (l inner) new(lang language.Tag, level int, placeholders InnerPlaceholders) string {
	if level == 1 {
		lang, _, _ = Matcher.Match(lang)
	}
	switch lang {
	case en:
		return fmt.Sprintf(l.en, placeholders.en()...)
	case fr:
		return fmt.Sprintf(l.fr, placeholders.fr()...)
	}
	parent := lang
	if level > 0 {
		parent = lang.Parent()
	}
	return l.new(parent, level+1, placeholders)
}

func (l inner) New(ctx context.Context, placeholders InnerPlaceholders) string {
	lang, _ := lexigo.FromCtx(ctx)
	return l.new(lang, 0, placeholders)
}

func (l inner) NewFromString(lang string, placeholders InnerPlaceholders) string {
	tag, _ := language.Parse(lang)
	return l.new(tag, 0, placeholders)
}

func (l inner) NewFromTag(lang language.Tag, placeholders InnerPlaceholders) string {
	return l.new(lang, 0, placeholders)
}

type InnerPlaceholders struct {
	Placeholder1 string
	Placeholder2 any
}

func (p InnerPlaceholders) en() []any {
	return []any{p.Placeholder1, p.Placeholder2}
}

func (p InnerPlaceholders) fr() []any {
	return []any{p.Placeholder2, p.Placeholder1}
}

var outerValue = outer{Inner: innerValue}

type outer struct {
	Inner inner
}

var Locales = locales{MyLocale: myLocaleValue, MyLocaleAny: myLocaleAnyValue, MyLocaleFloat: myLocaleFloatValue, MyLocaleInt: myLocaleIntValue, MyLocaleStr: myLocaleStrValue, Outer: outerValue}

type locales struct {
	MyLocale      myLocale
	MyLocaleAny   myLocaleAny
	MyLocaleFloat myLocaleFloat
	MyLocaleInt   myLocaleInt
	MyLocaleStr   myLocaleStr
	Outer         outer
}
