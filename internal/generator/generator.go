package generator

import (
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"slices"
	"strings"

	"golang.org/x/text/language"
	"golang.org/x/text/language/display"

	"github.com/dave/jennifer/jen"
)

var placeholderMatcher = regexp.MustCompile(`{{\.(\S+)}}`)

type (
	Generator struct {
		languages     []language.Tag
		languagesMaps map[language.Tag]languageMap
		defaultLang   language.Tag
		writer        *writer
	}
	Params struct {
		SrcPath string
		PkgName string
	}
)

func NewGenerator(w io.Writer, params Params) (*Generator, error) {
	log.Printf("Starting Lexigo generator from src %q", params.SrcPath)

	var defaultLang language.Tag
	var languages []language.Tag
	languagesSrc := map[language.Tag][]byte{}
	var languagesDisplayNames []string
	if err := filepath.Walk(params.SrcPath, func(path string, info fs.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}

		if ext := filepath.Ext(info.Name()); ext == ".json" {
			seg := strings.Split(info.Name(), ".")
			tag, err := language.Parse(seg[0])
			if err != nil {
				return fmt.Errorf("failed to parse language from file name: %s: %w", info.Name(), err)
			}

			displayName := display.English.Languages().Name(tag)
			languagesDisplayNames = append(languagesDisplayNames, displayName)

			log.Printf("Found language file %q for %q", path, displayName)
			if seg[1] == "default" {
				if defaultLang != (language.Tag{}) {
					return fmt.Errorf("found 2 or more default language files")
				}
				log.Printf("Setting default language to %q", displayName)
				defaultLang = tag
			}

			languages = append(languages, tag)
			languagesSrc[tag], err = os.ReadFile(path)
			if err != nil {
				return err
			}
		}
		return nil
	}); err != nil {
		return nil, err
	}

	if len(languagesSrc) == 0 {
		return nil, fmt.Errorf("no locale file found")
	}

	log.Printf("Found %d locale files - %v", len(languagesDisplayNames), languagesDisplayNames)

	maps := make(map[language.Tag]languageMap, len(languagesSrc))
	for _, lang := range languages {
		var data map[string]any
		if err := json.Unmarshal(languagesSrc[lang], &data); err != nil {
			panic(err)
		}
		maps[lang] = data
	}

	g := &Generator{
		languages:     languages,
		languagesMaps: maps,
		defaultLang:   defaultLang,
		writer:        &writer{w},
	}

	if err := jen.
		Comment("Code generated by lexigo - DO NOT EDIT").Line().
		Id("package").Id(params.PkgName).
		Line().
		Id("import").
		Defs(
			jen.Lit("fmt"),
			jen.Lit("context"),
			jen.Lit("golang.org/x/text/language"),
			jen.Lit("github.com/MysteriousPotato/lexigo/pkg"),
		).
		Line().
		Var().
		DefsFunc(func(group *jen.Group) {
			for _, lang := range languages {
				group.Add(jen.
					Id(lang.String()).
					Op("=").
					Qual("golang.org/x/text/language", "MustParse").
					Call(jen.Lit(lang.String())),
				)
			}
		}).
		Line().Line().
		Var().Id("Matcher").Op("=").
		Qual("golang.org/x/text/language", "NewMatcher").
		Call(jen.Index().Qual("golang.org/x/text/language", "Tag").ValuesFunc(func(group *jen.Group) {
			for _, lang := range languages {
				group.Add(jen.Id(lang.String()))
			}
		})).
		Render(w); err != nil {
		return nil, err
	}

	if err := jen.Type().Id("locale").InterfaceFunc(func(group *jen.Group) {
		for _, lang := range languages {
			group.Add(jen.Id(lang.String()).Call().String())
		}
	}).Render(g.writer); err != nil {
		return nil, err
	}

	if err := jen.Type().Id("placeholders").InterfaceFunc(func(group *jen.Group) {
		for _, lang := range languages {
			group.Add(jen.Id(lang.String()).Call().Index().Any())
		}
	}).Render(g.writer); err != nil {
		return nil, err
	}

	if err := g.newStructType("Locale", jen.Statement{
		jen.Id("locale").Id("locale"),
		jen.Id("placeholders").Id("placeholders"),
	}); err != nil {
		return nil, err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  "Locale",
		Name:  "parse",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("lang").Qual("golang.org/x/text/language", "Tag"))
				group.Add(jen.Id("level").Int())
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.If(jen.Id("level").Op("==").Lit(1)).Block(
				jen.Id("lang, _, _").Op("=").Id("Matcher.Match(lang)"),
			),
			jen.Switch(jen.Id("lang")).BlockFunc(func(group *jen.Group) {
				for _, tag := range g.languages {
					group.Add(jen.Case(jen.Id(tag.String())).Block(
						jen.If(jen.Id("l").Dot("placeholders").Op("==").Nil()).Block(
							jen.Return(jen.Id("l").Dot("locale").Dot(tag.String()).Call()),
						),
						jen.Return(
							jen.Qual("fmt", "Sprintf").Call(
								jen.Id("l").Dot("locale").Dot(tag.String()).Call(),
								jen.Id("l").Dot("placeholders").Dot(tag.String()).Call().Op("..."),
							),
						),
					))
				}
			}),
			jen.Id("parent").Op(":=").Id("lang"),
			jen.If(jen.Id("level").Op(">").Lit(0)).Block(
				jen.Id("parent").Op("=").Id("lang").Dot("Parent").Call(),
			),
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("parent"))
				group.Add(jen.Id("level+1"))
			})),
		},
	}); err != nil {
		return nil, err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  "Locale",
		Name:  "FromCtx",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("ctx").Qual("context", "Context"))
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.List(jen.Id("lang"), jen.Id("_")).Op(":=").Qual("github.com/MysteriousPotato/lexigo", "FromCtx").Call(jen.Id("ctx")),
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("lang"))
				group.Add(jen.Lit(0))
			})),
		},
	}); err != nil {
		return nil, err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  "Locale",
		Name:  "FromString",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("lang").String())
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.List(jen.Id("tag"), jen.Id("_")).Op(":=").Qual("golang.org/x/text/language", "Parse").Call(jen.Id("lang")),
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("tag"))
				group.Add(jen.Lit(0))
			})),
		},
	}); err != nil {
		return nil, err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  "Locale",
		Name:  "FromTag",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("lang").Qual("golang.org/x/text/language", "Tag"))
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("lang"))
				group.Add(jen.Lit(0))
			})),
		},
	}); err != nil {
		return nil, err
	}

	return g, nil
}

func (g *Generator) Exec(fieldName string) error {
	return g.exec(fieldName, "")
}

func (g *Generator) exec(fieldName, namespace string) error {
	if namespace != "" {
		log.Printf("Generating %q locale", namespace)
	}

	langData := g.languagesMaps[g.defaultLang]
	nsData, err := langData.get(namespace)
	if err != nil {
		return fmt.Errorf("invalid namespace %q for %q locale file: %w", namespace, g.defaultLang.String(), err)
	}

	valueOf := reflect.ValueOf(nsData)
	switch valueOf.Kind() {
	case reflect.Map:
		return g.newNestedLocale(fieldName, namespace, valueOf)
	case reflect.String:
		return g.newLocale(fieldName, namespace, nsData.(string))
	default:
		return fmt.Errorf("unsupported type %q in locales file", valueOf.Type())
	}
}

func (g *Generator) newNestedLocale(fieldName, namespace string, valueOf reflect.Value) error {
	fieldName, typeName, valueName, _ := getNames(fieldName)

	if namespace == "" {
		valueName = toPascalCase(typeName)
	}

	keys := valueOf.MapKeys()
	slices.SortFunc(keys, func(a, b reflect.Value) int {
		key1 := a.String()
		key2 := b.String()

		if key1 > key2 {
			return 1
		}
		if key1 < key2 {
			return -1
		}
		return 0
	})

	typeCodes := make(jen.Statement, len(keys))
	valueCodes := make(jen.Statement, len(keys))
	for _, key := range keys {
		eleFieldName := key.String()
		if err := g.exec(eleFieldName, extendNamespace(namespace, eleFieldName)); err != nil {
			return err
		}
		eleFieldName, eleTypeName, _, _ := getNames(eleFieldName)

		valueCodes.Add(jen.Id(eleFieldName).Op(":").Id(eleTypeName + "{}"))
		typeCodes.Add(jen.Id(eleFieldName).Id(eleTypeName))
	}

	if namespace == "" {
		if err := g.newStructInstance(valueName, typeName, valueCodes); err != nil {
			return err
		}
	}
	if err := g.newStructType(typeName, typeCodes); err != nil {
		return err
	}

	return nil
}

func (g *Generator) newLocale(fieldName, namespace, locale string) error {
	fieldName, typeName, _, placeholdersType := getNames(fieldName)

	_, placeholders, err := extractPlaceholders(locale)
	if err != nil {
		return fmt.Errorf("failed to extract placeholders from %q: %w", namespace, err)
	}

	if err := g.newType(typeName, "struct {}"); err != nil {
		return err
	}

	langPlaceholdersMap := make(map[language.Tag][]field, len(g.languagesMaps))
	langSwitchCodes := make(jen.Statement, len(g.languagesMaps))
	for _, tag := range g.languages {
		lang := g.languagesMaps[tag]
		locale, err := lang.get(namespace)
		if err != nil {
			return fmt.Errorf("invalid namespace %q for %q locale file: %w", namespace, tag.String(), err)
		}

		localeStr, langPlaceholders, err := extractPlaceholders(locale.(string))
		if err != nil {
			return fmt.Errorf("failed to extract placeholders from %q: %w", namespace, err)
		}

		if len(placeholders) != len(langPlaceholders) {
			return fmt.Errorf(
				"%q missmatched placeholders for %q file: expected %d placholders, got %d",
				namespace,
				tag.String(),
				len(placeholders),
				len(langPlaceholders),
			)
		}
		for _, p := range placeholders {
			if !slices.Contains(langPlaceholders, p) {
				return fmt.Errorf(
					"%q missmatched placeholders for %q file: missing or invalid type for %q",
					namespace,
					tag.String(),
					p.Name,
				)
			}
		}

		if err := jen.
			Func().
			Params(jen.Id("l").Id(typeName)).
			Id(tag.String()).
			Call().
			String().
			Block(jen.Return(jen.Lit(localeStr))).
			Render(g.writer); err != nil {
			return err
		}

		langPlaceholdersMap[tag] = langPlaceholders
		langSwitchCodes.Add(jen.Case(jen.Id(tag.String())).Block(
			jen.ReturnFunc(func(group *jen.Group) {
				if placeholders == nil {
					group.Add(jen.Id("l").Dot(tag.String()).Call())
					return
				}

				group.Add(jen.Qual("fmt", "Sprintf").Call(
					jen.Id("l").Dot(tag.String()).Call(),
					jen.Id("placeholders").Dot(tag.String()).Call().Op("..."),
				))
			}),
		))
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  typeName,
		Name:  "parse",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("lang").Qual("golang.org/x/text/language", "Tag"))
				group.Add(jen.Id("level").Int())
				if placeholders != nil {
					group.Add(jen.Id("placeholders").Id(placeholdersType))
				}
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.If(jen.Id("level").Op("==").Lit(1)).Block(
				jen.Id("lang, _, _").Op("=").Id("Matcher.Match(lang)"),
			),
			jen.Switch(jen.Id("lang")).Block(langSwitchCodes...),
			jen.Id("parent").Op(":=").Id("lang"),
			jen.If(jen.Id("level").Op(">").Lit(0)).Block(
				jen.Id("parent").Op("=").Id("lang").Dot("Parent").Call(),
			),
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("parent"))
				group.Add(jen.Id("level+1"))
				if placeholders != nil {
					group.Add(jen.Id("placeholders"))
				}
			})),
		},
	}); err != nil {
		return err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  typeName,
		Name:  "FromCtx",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("ctx").Qual("context", "Context"))
				if placeholders != nil {
					group.Add(jen.Id("placeholders").Id(placeholdersType))
				}
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.List(jen.Id("lang"), jen.Id("_")).Op(":=").Qual("github.com/MysteriousPotato/lexigo", "FromCtx").Call(jen.Id("ctx")),
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("lang"))
				group.Add(jen.Lit(0))
				if placeholders != nil {
					group.Add(jen.Id("placeholders"))
				}
			})),
		},
	}); err != nil {
		return err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  typeName,
		Name:  "FromString",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("lang").String())
				if placeholders != nil {
					group.Add(jen.Id("placeholders").Id(placeholdersType))
				}
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.List(jen.Id("tag"), jen.Id("_")).Op(":=").Qual("golang.org/x/text/language", "Parse").Call(jen.Id("lang")),
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("tag"))
				group.Add(jen.Lit(0))
				if placeholders != nil {
					group.Add(jen.Id("placeholders"))
				}
			})),
		},
	}); err != nil {
		return err
	}

	if err := g.newMethod(method{
		Alias: "l",
		Type:  typeName,
		Name:  "FromTag",
		Params: jen.Statement{
			jen.CustomFunc(jen.Options{Separator: ","}, func(group *jen.Group) {
				group.Add(jen.Id("lang").Qual("golang.org/x/text/language", "Tag"))
				if placeholders != nil {
					group.Add(jen.Id("placeholders").Id(placeholdersType))
				}
			}),
		},
		ReturnTypes: jen.Statement{jen.String()},
		Body: jen.Statement{
			jen.Return(jen.Id("l").Dot("parse").CallFunc(func(group *jen.Group) {
				group.Add(jen.Id("lang"))
				group.Add(jen.Lit(0))
				if placeholders != nil {
					group.Add(jen.Id("placeholders"))
				}
			})),
		},
	}); err != nil {
		return err
	}

	var localeMethodParams *jen.Statement
	if placeholders != nil {
		localeMethodParams = jen.Id("placeholders").Id(placeholdersType)
	}

	if err := g.newMethod(method{
		Alias:       "l",
		Type:        typeName,
		Name:        "Locale",
		Params:      jen.Statement{localeMethodParams},
		ReturnTypes: jen.Statement{jen.Id("Locale")},
		Body: jen.Statement{
			jen.Return(jen.Id("Locale").ValuesFunc(func(group *jen.Group) {
				group.Add(jen.Id("locale").Op(": ").Id("l"))
				if placeholders != nil {
					group.Add(jen.Id("placeholders").Op(": ").Id("placeholders"))
				}
			})),
		},
	}); err != nil {
		return err
	}

	if placeholders != nil {
		if err := g.newStructType(placeholdersType, placeholders.toJen()); err != nil {
			return err
		}

		for _, tag := range g.languages {
			langPlaceholders := langPlaceholdersMap[tag]
			if err := g.newMethod(method{
				Alias:       "p",
				Type:        placeholdersType,
				Name:        tag.String(),
				ReturnTypes: jen.Statement{jen.Index().Any()},
				Body: jen.Statement{
					jen.Return(jen.Index().Any().ValuesFunc(func(group *jen.Group) {
						for _, p := range langPlaceholders {
							group.Add(jen.Id("p").Dot(p.Name))
						}
					})),
				},
			}); err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) newType(name string, subType string) error {
	return jen.Type().Id(name).Id(subType).Render(g.writer)
}

func (g *Generator) newStructType(name string, fields jen.Statement) error {
	return jen.Type().Id(name).Struct(fields...).Render(g.writer)
}

func (g *Generator) newStructTypeFunc(name string, fn func(*jen.Group)) error {
	return jen.Type().Id(name).StructFunc(fn).Render(g.writer)
}

func (g *Generator) newStructInstance(name, typeName string, fields jen.Statement) error {
	return jen.Var().Id(name).Op("=").Id(typeName).Values(fields...).Render(g.writer)
}

type method struct {
	Alias       string
	Type        string
	Name        string
	Params      jen.Statement
	ReturnTypes jen.Statement
	Body        jen.Statement
}

func (g *Generator) newMethod(method method) error {
	return jen.
		Func().
		Params(jen.Id(method.Alias).Id(method.Type)).
		Id(method.Name).
		Params(method.Params...).
		Params(method.ReturnTypes...).
		Block(method.Body...).
		Render(g.writer)
}
